:PROPERTIES:
:CUSTOM_ID: sec:cluster_splitting
:END:

The framework described in [[#sec:event_geom_developments]] is put to use in a concrete scenario.
Before the start of the thesis here described, it had been observed that some (relatively rare) events processed by the \ac{L1} \ac{S2} chain identified more clusters than the number of generated particles interacting in the detector.
For the single particle, this implies measuring two energy clusters arising from just one generated particle.
We say that the cluster that should have been measured was "split", hence the term /cluster splitting/.
At the \ac{TPG} level of the reconstruction, each cluster is supposed to refer to a single particle.
A different behaviour can degrade the detector's energy and position resolution, since:
- particles can be reconstructed with a lower energy than the true energy when only one cluster passes additional selections, since the energy distribution across the clusters can be asymmetric;
- particles can be reconstructed with a shifted position when only one cluster passes additional selections, since a part of the energy deposits will not contribute to the position calculation;
- the multiplicity of particles in the event can be affected, when both clusters are interpreted as separate particles.
These can negatively impact the \ac{L1} decision, and thus trigger efficiency.
While studying cluter splits we require the following additional selections:
+ $(E_{\text{Cluster}}-E_{\text{Gen}})/E_{\text{Gen}} < -0.35$, which only selects events where a split very likely happened, since on average \SI{\sim 50}{\percent} to \SI{60}{\percent} of the energy is split across the two clusters;
+ $\eta \in \left[1.7, 2.8\right]$, to avoid unwanted reconstruction effects at \ac{HGCAL} boundaries, where showers might be transversally cut.
With this sample, we observe cluster splits in \SI{\sim 1}{\percent} of the events.
In the remainder of this section we explain the reasons for the existence of cluster splits, and detail the techniques developed in the context of this thesis to mitigate or remove it.

* The origin of cluster splits

As seen in [[#sec:hgcal_trigger_primitives]], the first step of the \ac{S2} consists on reducing the detector's granularity by mapping \acp{TC} into projective \coordsa{} bins.
The physical dimensions of the bins are strongly dependent on their location: bins closer to the beamline (low \rz{}) will be much smaller than bins closer to the outer boundary of the \ac{Si} layers (high \rz{}).
Given \num{42} \rz{} bins in a \ac{CE-E} layer starting at $\text{R}=30\si{\cm}$ and ending at $\text{R}=150\si{\cm}$, the ratio of the physical areas of two far-away bins can reach \num{\sim 5}.
However, the distribution of \acp{TC} across \ac{HGCAL} is uniform.
This implies a larger number of \acp{TC} for low \rz{} bins.
This is intended, as regions closer to the beamline expect larger energy density or occupancies, and thus the binning should be finer to keep the local resolution high.
On a different but important note, the rectangular binning grid applied over the physical hexagonal \ac{TC} space inevitably introduces inhomogeneities in the distribution of \acp{TC}, since a perfect alignment of detector elements with \coordsa{} bins is not possible.
In other words, immediately adjacent bins, in both \rz{} and \ac{phi} dimensions, might have a significantly different number of associated \acp{TC}.
Differences are extremely dependent on the bin widths, but the effect is very pronounced with current \ac{S2} parameters.
The inhomogeinities are illustrated by the black dots in [[fig:tcmov]].

The non-uniformities introduce nonphysical biases, as the distribution of deposited energy in \coordsa{} bins might not closely follow the true one in the detector.
Whenever the \ac{TC}-to-bin mapping is such that an intermediate bin has fewer \acp{TC} compared to their neighbours, the energy deposited by single particles can follow a pattern with two maxima along \ac{phi}.
As a consequence, the seeding step, as described in [[#sec:hgcal_trigger_primitives]], finds two seeds.
Since each seed originates a cluster, two clusters are formed from a single particle.
The degradation of the detector's energy response and position resolution ensues.

#+NAME: fig:tcmov
#+CAPTION: Number of \acp{TC} present as function of the \ac{phi} bin index, for the lowest \rz{} bins, where bins are smaller and the difference between adjacent bins is thus the most extreme possible. Black dots show the original distribution, and red dots show the \ac{TC} distribution after running the =bye-splits= algorithm with $\lambda=0$. Related results show that \acp{TC}' assigned bin positions, with respect to their true positions, is always less than \SI{2}{\cm} for all layers and \rz{} bins.
#+BEGIN_figure
#+ATTR_LATEX: :width 1.\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/MovementTCs.pdf]]
#+END_figure

Previous studies [[cite:&sudah_ahuja]] have shown, unsurprisingly, that defining a \rz{}-dependent binning can mitigate the splits.
Specifically, binning schemes with finer bins in the low \rz{} regions improve the energy resolution.
However, and taking into account the intended \ac{FPGA} implementation, the added complexity requires additional firmware resorces, making it impractical.
In what follows we propose a solution which, besides performing better, does not impact hardware resources.  

* The "bye-splits" iterative algorithm
Splits are overwhelmingly located in the high-\rapidity{} region, where bins are smaller in the cartesian space and \ac{TC} counts are less homogeneous along \azimuth{}.
Indeed, while a \ac{TC} shift of one \azimuth{} bin may create a split, a \ac{TC} shifting one \si{\rz} bin is captured by the seeding window, creating no split.
In addition, the number of \azimuth{} bins is larger, naturally increasing the odds of \ac{TC} counts non-uniformity.
The \bsplits{} algorithm is run independently across \si{\rz} rows.
Only a subset of low-\si{\rz} rows is considered.
The goal of the algorithm is to modify the mapping of \acp{TC} to bins along \azimuth{}.
This is done in such a way as to reduce the variance of the number of \acp{TC} per bin, and consequently the number of splits.
\ac{TC} bin migrations should be minimized, with only one \azimuth{} bin shift at a time.
Indeed, despite wanting to reduce the splitting, the final mapping should still reflect the overall physical positions of TCs.
The algorithm defines a sliding window around three consecutive \azimuth{} bins, and circular boundary conditions are taken into account.
It computes, for each group of three bins, the differences $D_{\text{left}} = C_{2} - C_{1}$ and $D_{\text{right}} = C_{3} - C_{2}$ between their \ac{TC} counts $C$,
where the indexes 1 to 3 refer to the left, middle and right bin positions in the sliding window.
A pseudo-random number $x$ is sampled from an uniform distribution $\mathcal{U}(0,1)$ to decide whether the \ac{TC} position migration occurs on the left or right side of the window:

#+NAME: eq:side
\begin{equation}
   \text{Side}=
   \begin{cases}
     \text{left}, & \text{if}\ x\sim\mathcal{U}(0,1) < \frac{D_{\text{left}}}{|D_{\text{left}}|+|D_{\text{right}}|} \\
     \text{right}, & \text{otherwise}
   \end{cases}
\end{equation}

The randomness in \cref{eq:side} ensures the overall shape of the distribution of \ac{TC} counts along \azimuth{} is kept, while setting \ac{TC} migrations to be more likely when differences are larger.
Once a side has been chosen, the shift of a \ac{TC} is done by taking into account the relative distribution of \ac{TC} counts in the sliding window (there are four possibilities for a sliding window of size 3).
Taking the top right corner in \cref{fig:italgo} /b/ as an example, a \ac{TC} is moved from the side to the middle whenever the central bin has less \acp{TC} than its two neighbours.
Only one \ac{TC} is moved per window iteration.
After the shift, the sliding window moves with unitary stride.
We note that the direction in which the window moves does not impact the final mapping, since the variance of \ac{TC} counts per bin is independent of \azimuth{}.
The algorithm is run for all possible windows, forming one /epoch/.
After each epoch, the following termination condition is checked for every \azimuth{} bin $i$:

#+NAME: eq:termination
\begin{equation}
  \left|D_{\text{left}, i}\right| + \left|D_{\text{right}, i}\right| \leq \max\left\{1, \lambda \times \left(\left|D^{0}_{\text{left}, i}\right| + \left|D^{0}_{\text{right}, i}\right| \right) \right\}
\end{equation}

\noindent where $\lambda \in \left[0, 1\right]$ is a tunable parameter controlling the final \ac{TC} count variance, and $D^0$ refers to the differences before the algorithm was run. The $\max$ operator ensures convergence for low-$\lambda$ (more aggressive) runs.
As expected, running the algorithm with $\lambda=0$ provides an essentially flat \ac{TC} count distribution.

#+NAME: fig:italgo
#+CAPTION: Visualization of the inner workings of the \bsplits{} iterative algorithm. /a)/ \bsplits{} is run independently for all \si{\rz} rows, with a sliding window of size 3. /b)/ \ac{TC} migration is executed by assessing which of the four relative possible distributions of \ac{TC} counts is present for a particlar sliding window. The arrows represent the direction of \ac{TC} migration in red (blue) for a right (left) shift (see \cref{eq:side}).
#+BEGIN_figure
#+ATTR_LATEX: :width 1.\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/italgo.png]]
#+END_figure

For $\lambda=0$, we verify that all \acp{TC} move less than \SI{2}{\cm} along \azimuth{}, which implies they moved to their immediately adjacent bins only.
We also observe that the number of moving \acp{TC} decreases with \rapidity{}.
For the first, highest \rapidity{}, \si{\rz}-row almost 50\% moved.
This number dropped to \SI{\sim 11}{\percent} (\SI{\sim 8}{\percent}) for the 3\textsuperscript{th} (6\textsuperscript{th}) \si{\rz}-row.
The algorithm removes a significant portion of splits (see \cref{fig:byesplits_res}), and in \cref{fig:split} we visualize one such event.

#+NAME: fig:byesplits_res
#+CAPTION: Comparison between the default reconstruction (blue, labeled ``CMSSW'' \cite{cmssw}) and the same reconstruction running with the \bsplits{} TC-bin mapping (red). All events displayed satisfy $(E_{\text{Cluster}}-E_{\text{Gen}})/E_{\text{Gen}} < -0.35$. /Left)/ $\pt$ response; /Right)/ $\phi$ resolution.
#+BEGIN_figure
#+ATTR_LATEX: :width .49\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/byesplits_res.png]]
#+ATTR_LATEX: :width .49\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/byesplits_res_2.png]]
#+ATTR_LATEX: :width .49\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/byesplits_eta.png]]
#+ATTR_LATEX: :width .49\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/byesplits_2_eta.png]]
#+ATTR_LATEX: :width .49\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/byesplits_phi.png]]
#+ATTR_LATEX: :width .49\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/byesplits_2_phi.png]]
#+END_figure

Significant improvements in energy response and position resolution are obtained (\cref{fig:byesplits_res}).
We have also validated \bsplits{} by verifying that it does not impact the reconstruction of a sample where no splits are present.
The sample was obtained in a similar way as the one mentioned above, but requiring an energy response above -0.2.
Importantly, \bsplits{} is run offline, decoupled from the online reconstruction, and its \ac{TC}-to-bin output mapping can be encoded in a Look-up Table.
This implies that \bsplits{} does not impact firmware resources, while bringing significant benefits.
It is thus a strong candidate for the final design of the reconstruction chain[fn::Adapted versions of \bsplits{} are currently also being considered to address \ac{TC} assignment to \azimuth{} bins at the \ac{ECON-T}/\ac{S1} interface.]. 
The algorithm was presented in [[cite:&bruno_chep23]].

#+NAME: fig:split
#+CAPTION: Example of a cluster split for a single event in the \coordsa{} space, where colors represent energy deposited per bin in \tmip{} units. The orange cross shows the position of the generated photon. The top (bottom) row shows the same event before (after) applying the smoothing step. The left (right) column displays the event not considering (considering) the \bsplits{} algorithm, where the red (black) crosses show the position of the reconstructed clusters. Generated and reconstructed clusters become superimposed after running \bsplits{}.
#+BEGIN_figure
#+ATTR_LATEX: :width .495\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/split_nosmooth_before_mod.png]]
#+ATTR_LATEX: :width .495\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/split_nosmooth_after_mod.png]]
#+ATTR_LATEX: :width .495\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/split_smooth_before_mod.png]]
#+ATTR_LATEX: :width .495\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/split_smooth_after_mod.png]]
#+END_figure

* Parameter and algorithmic alternatives
Alternative approaches were also looked at, all of which have an impact on resources but reducing cluster splitting dramatically: increasing the size of the seeding window, modifying the smoothing kernel and using the energy prioritization clustering algorithm.

* Using detector coordinates
:PROPERTIES:
:CUSTOM_ID: sec:using_detector_coordinates
:END:

\ac{HGCAL}'s geometry uses non-cartesian coordinates to cover the hexagonal tessellation of its \ch{Si} modules and sensors.
Any mismatch between algorithmic and detector coordinates implies a non-trivial interface.
Therefore, besides creating cluster splits, \coordsa{} bins increase the complexity of routing \acp{TC} to bins, which is further complicated by the \coordsa{} varying bin area.
I explored the possibility of using detector coordinates for the reconstruction.
Hexagonal coordinates bring an increase in algorithmic complexity for navigation.
This however does not translate into increased firmware resource usage.
Three points must be adressed. 
However, hexagonal coordinates are non-projective.
We can thus only utilise groups of a few consecutive layers.
The two independent hexagonal coordinate systems (modules and TCs) have to be integrated.
In addition, the navigation and neighbor query are slightly more complex than in cartesian coordinates.
Together with another PhD candidate[fn::Marco Chiusi (1\up{st} year), currently responsible for efficiency measurements and optimization of the coarse seeding step.] I've put in place a preliminary \ac{CS} step selecting a small subset of all the modules per event.
The \ac{CS} can perform more than one selection per event.
It focuses on the shower maximum region, selecting four consecutive modules along a line parallel to the beamline, each module belonging to a different layer.
For each module selected, based on an energy sum threshold, all its 6 neighbours are also taken into account, to avoid artificially truncating showers.
I have designed and implemented a new seeding which receives \acp{TC} and finds local maxima directly in detector coordinates.
For each \ac{HGCAL} layer, the seeding projects modules into the same hexagonal coordinate system.
It translates local hexagonal \coordsb{} \ac{TC} coordinates into global ($u^{'},v^{'}$), using hexagonal module coordinates ($U,V$):

#+NAME: eq:matrix
\begin{equation}
  \begin{bmatrix}
    u^{'} \\
    v^{'} 
  \end{bmatrix}
  =-4
  \begin{bmatrix}
    1 & 2 \\
    2 & -1
  \end{bmatrix}
  \begin{bmatrix}
    U \\
    V 
  \end{bmatrix}
  +
  \begin{bmatrix}
    u \\
    v 
  \end{bmatrix}
\end{equation}

\noindent where the numbers reflect the structure of the modules and of the hexagonal tessellation.
They can be expressed as powers of 2, facilitating their implementation in the firmware.
The seeding was integrated with another recently developed step that selects subsets of \acp{TC} before finding the seeds, called \ac{CS}.
The \coordsa{} histogramming and smoothing steps are completely removed.
We run the processing chain with the new seeding and compare it with the \coordsa{} one.
Energy response and position resolution remain virtually identical (\cref{fig:uv_dist}, top).
The clustering step looses a small amount of energy compared to what is available (\cref{fig:uv_dist} left).
Interestingly, we observe an almost complete removal of cluster splits, without using any of the methods described previously.

#+NAME: fig:hexag_coords
#+CAPTION: Figure caption.
#+BEGIN_figure
#+ATTR_LATEX: :width 1.\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/HexagonalCoordinates.pdf]]
#+END_figure

#+NAME: fig:hexag_coords_event
#+CAPTION: Simulated event in a single \ac{HGCAL} layer. (Left) Physical distribution of \acp{TC}. (Right) Distribution of the same \acp{TC} in a square grid.
#+BEGIN_figure
#+ATTR_LATEX: :width 1.\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/HexagonalCoordinatesEvent.pdf]]
#+END_figure

#+NAME: fig:uv_dist
#+CAPTION: Energy response (left) and $\phi$ resolution (right) for the \coordsa{} (blue) and \coordsb{} (orange) reconstruction chains. In green we display the same quantities obtained with all \acp{TC} (the position is weighted by \ac{TC} energy). /Bottom)/ Average number of seeds as a function of energy (left) and $|\eta|$ (right). The CS chain naturally removes cluster splits.
#+BEGIN_figure
#+ATTR_LATEX: :width .49\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/uv_dist_en_mod_label.png]]
#+ATTR_LATEX: :width .49\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/uv_dist_phi_mod_label.png]]
#+ATTR_LATEX: :width .49\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/uv_multiplicity_en.png]]
#+ATTR_LATEX: :width .49\textwidth :center
[[~/org/PhD/Thesis/figures/hgcal/uv_multiplicity_eta.png]]
#+END_figure
